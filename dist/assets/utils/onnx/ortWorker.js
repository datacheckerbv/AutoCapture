let ortSession=null,inputName=null;const normalizeMeanStd=e=>ort.Tensor.fromImage(e,{dataType:"float32",tensorFormat:"RGB",norm:{bias:-128,mean:127.5}}),normalizeRescale=e=>ort.Tensor.fromImage(e,{dataType:"float32",tensorFormat:"RGB",norm:{bias:0,mean:255}});self.onmessage=async e=>{const{type:a,payload:s}=e.data||{};try{if("init"===a)importScripts(s.ortScriptUrl),s.wasmPaths&&(ort.env.wasm.wasmPaths=s.wasmPaths),ort.env.wasm.numThreads=1,ort.env.wasm.simd=!0,ort.env.wasm.proxy=!1,ortSession=await ort.InferenceSession.create(s.modelBuffer,{executionProviders:["wasm"],enableCpuMemArena:!1,enableMemPattern:!1,graphOptimizationLevel:"basic"}),inputName=ortSession.inputNames[0],self.postMessage({type:"ready",payload:{inputName}});else if("run"===a){if(!ortSession)throw new Error("ORT session not initialized");let e;if(s.tensor&&s.tensor.buffer&&s.tensor.dims){const{buffer:a,dims:t,dtype:o="float32"}=s.tensor,r=new Float32Array(a);e=new ort.Tensor(o,r,t)}else switch(s.normalization){case"meanStd":e=await normalizeMeanStd(s.imageData);break;case"rescale":e=await normalizeRescale(s.imageData);break;default:throw new Error(`Unknown normalization: ${s.normalization}`)}const a={[inputName]:e},t=await ortSession.run(a),o={};for(const[e,a]of Object.entries(t))o[e]=Array.from(a.data);self.postMessage({type:"result",payload:o})}else if("dispose"===a)try{ortSession&&await ortSession.release(),ortSession=null,inputName=null,self.postMessage({type:"disposed"}),self.close()}catch(e){self.postMessage({type:"error",payload:`Dispose error: ${String(e?.stack||e)}`}),self.close()}}catch(e){console.error(e),self.postMessage({type:"error",payload:String(e?.stack||e)})}};